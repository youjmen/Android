# Clean Architecture

## 클린 아키텍쳐는 왜 설계 되었는가?

많은 개발자들이 소프트웨어를 설계하며 여러 아키텍쳐에 대한 의견을 제시했다. 이 여러 아키텍쳐들은 세부적으로 다른 점들이 있었지만 SoC라는 공통적인 목표를 갖고 있다.

SoC를 하는 이유는 소프트웨어를 분리함으로써 각각의 시스템들을 독립시키고, 의존성이 없게 한다. 독립적이고, 의존성이 없어 각각의 시스템들을 쉽게 테스트, 재사용할 수 있게 만들고, 확장을 하기에도 용이하게 만들어 변경사항이 일어나더라도 쉽게 대처할 수 있게 설계한 것이 아키텍쳐들이다.

이 여러 아키텍쳐들을 하나의 아이디어로 통합하려 한 것이 클린 아키텍쳐인 것이다.
## 클린 아키텍쳐는 어떻게, 어떤 효과를 내는가?

계층을 분리함으로써, SoC를 구현한다. 각기 다른 시스템들이 서로 의존적이면, 높은 결합도로 인해 프레임 워크가 바뀌거나, DB를 기존 SQlite에서 MongoDB로 바꾸거나 할 때 그 시스템을 사용하던 의존적인 시스템들이 다 바뀌어야 한다.
그러므로 변경에 잘 대응할 수 있는 소프트웨어를 위하여 아키텍쳐는 설계된 것이다.

![](http://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)

업무 규칙(Business Rule)은 소프트웨어 시스템의 핵심적인 기능이다. 소프트웨어는 이 업무 규칙을 위하여 설계되고, 존재한다.
예) 은행의 출금 기능, 계좌 내역, 
쇼핑몰의 상품 목록, 상품 구매 등

Entity : 핵심 업무 규칙, 데이터.
이 Entity는 어느 어플리케이션이든 변하지 않는다. 어플리케이션에 구속되는 것이 아니다.
웹 어플리케이션이든 앱이든 윈도우 프로그램이든, 이 규칙은 변하지 않는다.

예) 적금 이자율, 대출 한도, 헬스장 최대 인원 수, 소득세 계산하는 법, 유저 정보엔 어떤 요소가 있는지 등 

Usecase : 어플리케이션 특화 규칙, 어플리케이션에 따라 엔티티를 어떻게 사용하고, 사용자의 입력은 어떻게 제공되어야 하는지와 같은 어플리케이션의 규칙과 처리단계를 정의하고, 사용되는 법을 설명하는 곳.

Usecase는 위와 같이 설계한 방식대로 작동하게 하는 역할을 한다. 그러므로 Entity의 의도를 잘 드러내야 한다. Entity가 쇼핑몰에 관한 내용이라면, Usecase는 어플리케이션이 쇼핑몰로 보이게 Entity의 의도를 어플리케이션 내에서 드러나게 해야한다.

예) 회원 가입 절차 : 아이디와 비밀번호를 입력받고, 승인 문자를 입력한 뒤 확인을 하면 DB에 고객 정보를 등록한다.

![](https://miro.medium.com/max/875/1*vcnYWWn_zhNk6I30meBaPg.png)
ProAndroidDev에서 발췌한 이 사진은 4개의 원을 Presentation, Domain, Data Layer로 나누어 놨다.

이렇게 3개의 Layer로 나누어 놓은 이유는 
UI, 비즈니스 로직, Data간의 의존성을 분리하기 위해서이다.

나는 처음에 Usecase와 Repository가 비슷하다고 생각했다.

왜냐하면 처음에 비즈니스 로직이라는 것을 이해하지 못했었다.
그래서 Usecase와 Repository 둘 다 Usecase는 Viewmodel에 데이터를 제공하고, Repository는 Datasource의 데이터를 제공하는, 데이터를 제공하는 부품들이라 생각해서 뭐하러 둘이 나눠 놓은지 몰랐었다.

하지만 Usecase는 Entity,즉 비즈니스 규칙의 의도를 표현하는 어플리케이션에서의 Entity를 가장 잘 표현하기 위한 것이다.


Repository는 오히려 Presenter와 비슷하게 Presenter가 View와 Domain의 의존성을 분리하듯이, Data와 Domain의 의존성을 분리하기 위하여 Usecase에서 의존성을 분리하여 독립성을 유지하기 위해 사용하는 것에 불과하다.